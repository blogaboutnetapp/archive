<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	>
<channel>
	<title>Комментарии к записи: Результаты тестирования FC и Software iSCSI под MS Hyper-V R2</title>
	<atom:link href="http://blog.aboutnetapp.ru/archives/601/feed" rel="self" type="application/rss+xml" />
	<link>http://blog.aboutnetapp.ru/archives/601</link>
	<description>Системы хранения данных как предмет разговора</description>
	<pubDate>Wed, 07 Apr 2021 12:07:08 +0000</pubDate>
	<generator>http://wordpress.org/?v=2.6</generator>
		<item>
		<title>Автор: Korj</title>
		<link>http://blog.aboutnetapp.ru/archives/601#comment-441</link>
		<dc:creator>Korj</dc:creator>
		<pubDate>Thu, 20 May 2010 10:34:58 +0000</pubDate>
		<guid isPermaLink="false">http://blog.aboutnetapp.ru/?p=601#comment-441</guid>
		<description>Максимальная нагрузка с 4 серверов была 2.7Гбит/с, т.е. не выше 675Мбит/с. Следовательно, даже 1ГБит/с карат не была даже близка к перегрузке. Соответственно не имели особого значения и JF, поскольку хватало пропускной и для неоптимальных 1.5-киловых пакетов, да и нагрузка была столь плотной, что карта всё что надо на 1 уровне собирала в большие фреймы. 
Что меряли? Latency ограничена хранилкой, минимум шёл 4ms, что для аппаратной коммутации в неперегруженной сети - долго. IOPS-ы, опять же выдаваемые хранилкой? Ну выдавала она нормальные свои IOPS-ы, которые на этой нагрузке и должна была выдавать - при чём тут метод подключения?
Был бы другой паттерн - не 100% random 8k, возможно хранилка выдала бы больше, и тогда б что-то упёрлось уже в сеть. Пока упёрлось всё в хранилку, точнее в конечную latency жестких дисков. Хранилка не перегружена - да, но latency имеет ту, что имеет, что и ограничивает результат.
Хотели показать, что на 100% random 4-8k не нужно ничего, кроме 1G iSCSI? А почему именно такой паттерн? Со стороны сервера может и не нужно, а хранилка как подключалась? Небось же не одним портом 1G Ethernet - вот об этом и речь, когда говорят о 10G том же.

Вы пишете:
"в том числе и на 512 outstanding IOs (очень высокая загрузка)"
На самом деле это на все 32 машины - каждая машина нагружалась до 16 OIO.
Вы же писалиЖ
"Значение Outstanding IOs от 1 до 8 относится к очень “легким” программам, 128 и 256 - очень “тяжелым”."
Следовательно нагрузка была легкой, по вашей же терминологии.</description>
		<content:encoded><![CDATA[<p>Максимальная нагрузка с 4 серверов была 2.7Гбит/с, т.е. не выше 675Мбит/с. Следовательно, даже 1ГБит/с карат не была даже близка к перегрузке. Соответственно не имели особого значения и JF, поскольку хватало пропускной и для неоптимальных 1.5-киловых пакетов, да и нагрузка была столь плотной, что карта всё что надо на 1 уровне собирала в большие фреймы.<br />
Что меряли? Latency ограничена хранилкой, минимум шёл 4ms, что для аппаратной коммутации в неперегруженной сети - долго. IOPS-ы, опять же выдаваемые хранилкой? Ну выдавала она нормальные свои IOPS-ы, которые на этой нагрузке и должна была выдавать - при чём тут метод подключения?<br />
Был бы другой паттерн - не 100% random 8k, возможно хранилка выдала бы больше, и тогда б что-то упёрлось уже в сеть. Пока упёрлось всё в хранилку, точнее в конечную latency жестких дисков. Хранилка не перегружена - да, но latency имеет ту, что имеет, что и ограничивает результат.<br />
Хотели показать, что на 100% random 4-8k не нужно ничего, кроме 1G iSCSI? А почему именно такой паттерн? Со стороны сервера может и не нужно, а хранилка как подключалась? Небось же не одним портом 1G Ethernet - вот об этом и речь, когда говорят о 10G том же.</p>
<p>Вы пишете:<br />
&#8220;в том числе и на 512 outstanding IOs (очень высокая загрузка)&#8221;<br />
На самом деле это на все 32 машины - каждая машина нагружалась до 16 OIO.<br />
Вы же писалиЖ<br />
&#8220;Значение Outstanding IOs от 1 до 8 относится к очень “легким” программам, 128 и 256 - очень “тяжелым”.&#8221;<br />
Следовательно нагрузка была легкой, по вашей же терминологии.</p>
]]></content:encoded>
	</item>
</channel>
</rss>
