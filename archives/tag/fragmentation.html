<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="ru-RU">

<head profile="http://gmpg.org/xfn/11">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<title>about NetApp   &raquo; fragmentation</title>

<link rel="stylesheet" href="../../wp-content/themes/fluid-blue/style.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../wp-content/themes/fluid-blue/print.css" type="text/css" media="print" />
<link rel="alternate" type="application/rss+xml" title="about NetApp RSS Feed" href="../../feed" />
<link rel="pingback" href="../../xmlrpc.php.html" />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="../../xmlrpc.php%3Frsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="../../wp-includes/wlwmanifest.xml" /> 
<meta name="generator" content="WordPress 2.6" />

</head>

<body>
<div id="page">
<div id="header">
	<div id="headertitle">
		<h1><a href="../../index.html" title="about NetApp: Системы хранения данных как предмет разговора">about NetApp</a></h1>
		<p>Системы хранения данных как предмет разговора</p>
	</div> 
	<!-- Search box (If you prefer having search form as a sidebar widget, remove this block) -->
	<div class="search">
		<form method="get" id="searchform" action="../../index.html">
<input type="text" size="20" name="s" id="s" value="Поиск..."  onblur="if(this.value=='') this.value='Поиск...';" onfocus="if(this.value=='Поиск...') this.value='';"/>
</form>
	</div> 
	<!-- Search ends here-->
		
</div>

<div id="navbar">
<ul id="nav">
	<li><a href="../../index.html">Home</a></li>
	<li class="page_item page-item-153"><a href="../../about/trackback.html" title="about">about</a></li>
<li class="page_item page-item-215"><a href="../../distributory-v-rossii/trackback.html" title="Дистрибуторы в России">Дистрибуторы в России</a></li>
<li class="page_item page-item-1327"><a href="../../disti-ua/trackback.html" title="Дистрибуторы в Украине">Дистрибуторы в Украине</a></li>
</ul>
</div>
<div id="wrapper">

	<div id="content">

	
			<p>Posts tagged &#8216;fragmentation&#8217;</p>

	 		
		<div class="navigation">
			<div class="alignleft"></div>
			<div class="alignright"></div>
		</div>

						
			<div class="post" id="post-1294">
				<h2 class="posttitle"><a href="../1294/trackback.html" rel="bookmark" title="Permanent Link to Reallocation в Data ONTAP. Часть 2.">Reallocation в Data ONTAP. Часть 2.</a></h2>
				<div class="postmetadata">30 Сентябрь 2013, 12:11 <!-- от  --></div>
				<div class="postentry">
					<p>На прошлой неделе мы начали собирать в кучку все то, что мы знаем о процессе reallocate в Data ONTAP. В части первой я особо остановился на том, чем отличается знакомая вам всем “фрагментация” на файловых системах типа FAT, и чем она отличается от inode-овых экстентных FS, ведущих свое происхождение от BSD, и почему нельзя напрямую называть <em>non-contiguous block allocation</em> – “фрагментацией”, как это часто делается в <em>говнилках</em>. Равно как и называть процесс reallocate – “дефрагментацией”, хотя отчасти в его задачу действительно входит процедура оптимизации размещения блоков WAFL. Сегодня сосредоточимся именно на reallocate и его работе.</p>
<p>Одна из ключевых проблем WAFL, требующих использования reallocate, это так называемые “дисковые hot spots” аномально загруженные физические диски в нем, если брать их в сравнении с остальными дисками на aggregate. Происходит это вот от чего обычно.</p>
<p>Представим себе, что у нас есть aggregate из нескольких дисков. Диски постепенно заполняются данными.</p>
<p><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="/pics/cbaf94be46c1_DF2A/image.png" width="507" height="321" /></p>
<p>В какой-то момент мы решаем, что aggregate нужно расширить, и добавляем в него несколько физических дисков. Это возможно, и довольно часто используется.</p>
<p><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="/pics/cbaf94be46c1_DF2A/image_3.png" width="689" height="156" /></p>
<p>Но как вы, должно быть помните, принципы работы WAFL таковы, что записываемые, и даже изменяемые в уже записанных блоках данные, не записываются в “старые места”, а пишутся на пространство в пуле свободных блоков. В ситуации же, когда основные диски уже были почти полны (как это и бывает обычно перед расширением), а новых добавлено немного, у нас получается картина, когда пространство пула свободных блоков почти все сосредоточено на этих нескольких добавленных (и поэтому, естественно, пока пустых) дисках. А так как изменяемые и записываемые данные обычно автоматически являются и самыми “горячими”, ведь скорее всего вы и прочитаете те данные, которые только что записали, они свежие и активные, куда активнее чем то, что там где-то в глубинах терабайтов лежит, то возникает ситуация, когда на добавленные в aggregate новые диски постепенно перенесутся все, или большая часть новых, оперативных данных, и, следовательно, существенная часть дисковой нагрузки всего aggregate как на запись, так и на чтение.</p>
<p><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="/pics/cbaf94be46c1_DF2A/image_4.png" width="672" height="238" /></p>
<p>Возникает так называемый <font color="#ff0000">disk hot spot</font>.</p>
<p><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="/pics/cbaf94be46c1_DF2A/image_5.png" width="672" height="269" /></p>
<p><em>(“свежие”, а потому активные данные, скопились на нескольких добавленных дисках)</em></p>
<p>Оценить сравнительную загрузку физических дисков в aggregate можно с помощью <a href="../1116/trackback.html">вывода команды stats</a>, или искользуя скрипты, их использующие, о некоторых я <a href="../725/trackback.html">уже писал</a>. Если вы уже побежали мерять свою систему, замечание вдогонку: вы, возможно, заметите на ней два сильно недозагруженных, по сравнению с прочими, диска в каждой RAID-группе (это видно и на скриншоте в посте выше). Да, это Parity и Double Parity диски RAID-группы, при штатной работе системы это нормально, не обращайте на это внимания, смотрите на те, которые выше и постоянно выше среднего по группе загружены.</p>
<p><img title="netapp-disk-hotspot" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="netapp-disk-hotspot" src="/pics/cbaf94be46c1_DF2A/netapp-disk-hotspot.jpg" width="642" height="184" /></p>
<p><em>(обратите внимание на параметр ut% (utilization) для диска 0d.26 на скриншоте выше)</em></p>
<p>Кстати сказать, описанная выше ситуация не является эксклюзивной для NetApp, например та же проблема встречается в <a href="../969/trackback.html">disk pools на EMC VNX</a>, и это именно та причина, по которой EMC не рекомендует добавлять в пул лишь по нескольку отдельных дисков, а только в количестве, кратном уже имеющейся емости RAID-групп пула, что очевидно, довольно жестокая негибкость для кастомера. У VNX ситуация усложняется еще и тем, что довольно долго после релиза системы у них не было вообще никаких средств реаллокации блоков и способов развномерно “растасовать” блоки при расширении пула.</p>
<p>Вот как раз в такой ситации нам на помошь придеть reallocation. С его помощью вы сможете равномерно перераспределить блоки с имеющихся дисков, на все, включая новые добавленые. Одна из причин возникновения “хотспотов” таким образом будет устранена. Помните, однако, что вам необходимо проделать это со <strong>всеми</strong> томами данного aggregate, о этом аспекте мы поговорим подробнее в части третьей. На приведенном рисунке я нарисовал простейшую схему с одним томом на aggregate, обычно же у вас несколько томов, а операция <em>volume reallocate</em> работает с отдельным томом, а не с aggregate в целом. Существует, однако, опция <em>aggregate reallocation</em>, но она предназначена для другого, об этом также отдельно.</p>
<p><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="/pics/cbaf94be46c1_DF2A/image_6.png" width="672" height="269" /></p>
<p>Вот в чем причина, почему в случае расширения aggregate вам скорее всего будет крайне полезно сделать <em>reallocate</em>. Польза от его использования зависит, как вы видите из изложенного выше, от многих факторов. Когда-то она может и вовсе не проявиться, когда-то быть довольно существенной.</p>
<p>Например в communities.netapp я однажды нашел такое мини-исследование по результатам добавления дисковой полки к системе FAS2020 (aggr0 – 10 дисков, default RAID group size (16)). Дискова полка на 14 дисков к уже имеющимся 12 дискам&#160; – это не тот случай, который вызовет явно наблюдаемые хотспоты дисков, но все же результаты интересные:</p>
<p>&#160;</p>
<p><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="/pics/cbaf94be46c1_DF2A/image_7.png" width="929" height="344" /></p>
<p>Крайние правые столбцы – система на нагрузке под SQL Server до добавления дисков (64K blocks, 100% random, 65% read/35% write). Средняя группа столбцов – сразу после добавления и без reallocate. Как вы видите, предсказуемо выросли IOPS, уменьшился responce time. Однако после добавления полки и измерения была проведена <em>volume reallocation</em> (в процессе ее CPU util - ~70-75%, disk util ~65%) с параметрами: </p>
<p><code>reallocate –f –p /vol/volX</code></p>
<p>Вы видите, что в результате несколько выросли показатели по IOPS, и несколько снизились показатели response time. Непринципиально, но процентов 15 таким образом удалось на системе наковырять. По моим оценкам польза от reallocation (и, кстати, соответственно, “вред” от пресловутой “фрагментации на NetApp”, вниманию любителей верить говнилкам) примерно в 10-15% и укладывается, в самых синтетически ужасных случаях на моих тестах – 20-25%.</p>
<p>Продлолжение следует.</p>
				</div>
		
				<div class="postmetadata">
					Метки: <a href="fragmentation.html" rel="tag">fragmentation</a>, <a href="netapp/index.html" rel="tag">netapp</a>, <a href="reallocate.html" rel="tag">reallocate</a>, <a href="reallocation.html" rel="tag">reallocation</a><br />					Раздел: <a href="../category/techtalk/index.html" title="Просмотреть все записи в рубрике &laquo;techtalk&raquo;" rel="category tag">techtalk</a>&nbsp;&nbsp;|&nbsp;
					<a href="../1294/trackback.html#comments" title="Комментарий к записи Reallocation в Data ONTAP. Часть 2.">1 комментарий</a>									 </div>
			</div>
	
						
			<div class="post" id="post-1292">
				<h2 class="posttitle"><a href="../1292/trackback.html" rel="bookmark" title="Permanent Link to Reallocation в Data ONTAP. Часть 1.">Reallocation в Data ONTAP. Часть 1.</a></h2>
				<div class="postmetadata">23 Сентябрь 2013, 8:00 <!-- от  --></div>
				<div class="postentry">
					<p>Многие мои посты тут пишутся заранее, и потом <em>отлеживаются</em>. Некоторые – отлеживаются в моей голове. Но среди них есть порой и настоящие старожилы, вот, например, посту на тему того, как работает reallocation в WAFL и Data ONTAP, скоро уж три года. Все это время я пытаюсь сложить полноценную, непротиворечивую и исчерпывающую картину вопроса, чтобы изложить это все в блоге. Проблема в том, что, вследствие закрытости многих механизмов работы Data ONTAP (а также того, что они меняются, а закрытость позволяет не рассказывать публике об изменениях в деталях), многие вопросы остаются для меня не исчерпывающе отвеченными. Но, тем не менее, давайте перестанем тянуть кота за хвост, и приступим к тому, что нам известно, и о чем можно рассказать.</p>
<p>Тема процесса перекомпоновки блоков данных в структурах WAFL всегда была <em>темноватой</em>, и, как любая тема, испытывающая недостаток ясности, она раз за разом становится поводом для более или менее честных <a href="../1272/trackback.html">спекуляций</a>, причем не только со стороны <a href="../1266/trackback.html">конкурентов NetApp</a> по рынку систем хранения данных, но, зачастую, и среди самих пользователей. Типичным ходом в такой спекуляции является назвать процессы записи на WAFL – “фрагментацией”, и, готово дело, дальше уже можно пугать потенциальных клиентов NetApp жупелом, растущим еще из FAT и обязательного Norton Defragment с бегающими квадратиками.</p>
<p>О том, насколько на самом деле так называемая “фрагментация” на WAFL влияет на производительность я уже <a href="fragmentation.html">писал не раз</a>, не стану повторяться, все есть по ссылкам выше, сегодня поговорим об обратном процессе, что же представляет собой процесс <em>reallocation</em>.</p>
<p><strong>Reallocation</strong> – это фоновый процесс в OS Data ONTAP, который оптимизирует и перераспределяет структуру хранения блоков WAFL для оптимизации к ним доступа. Он близко связан с тем, как именно происходит запись данных на WAFL в OS Data ONTAP. Не вполне корректно называть процесс реаллокации - “дефрагментацией”, как и проводить аналогии с файловой системой, например FAT, построенной на совсем иных&#160; принципах выделения пространства. Многие годы считалось, например, что файловые системы Linux (читай inode-овые BSD-like файловые системы, с использованием идей которых создана и WAFL) <a href="https://www.google.co.th/search?q=linux+не+требует+дефрагментации">вообще не подвержены фрагментации</a>, так, до ext4 там вообще не существовало штатных средств “дефрагментации”, и ничего, работали же, а многие системы в продакшне и на ext3fs работают и до сих пор. Но, конечно, фрагментация, или, корректнее <em>non-contiguous file allocation</em> существует и в них, и с ростом дисковой нагрузки на серверные системы в целом, и увеличении объемов хранения, несомненно эта проблема стала все более заметной. Оставим сейчас в стороне спор, насколько фрагментация данных влияет в условиях, когда практически 100% workload составляет не sequental, а random access, об этом <a href="../455/trackback.html">я уже писал</a>, поговорим о том, что же можно сделать для оптимизации структуры хранения путем вот этой самой block reallocation. Подобной “фрагментации” данных подверженны все системы хранения (особенно использующие современные фишечки работы с данныеми, такие как снэпшоты, дисковые пулы, thin provisioning, а не просто dumb SCSI LUN). Но не все умеют с этим бороться.     <br />NetApp – умеет.</p>
<p>В документации сказано скупо:</p>
<p><em><strong>reallocate</strong> - Command for managing reallocation of files, LUNs, volumes, and aggregates</em></p>
<p><em>The <strong>reallocate</strong> family of commands manages the allocation, or layout optimization, of large files and       <br />LUNs on a node. Additionally all files in a volume may be reallocated, and the block layout of       <br />aggregates may be optimized. Using the <strong>reallocate</strong> command, layout measurement and optimization       <br />(reallocation) can be automated.</em></p>
<p>Определенную сложность для пользователей вызывает тот факт, что процесс reallocate не запущен на системе по умолчанию. Сделано это, по всей видимости, исходя из главного принципа, которым руководствуется NetApp, назначая свои значения по умолчанию. Даже если вы не прочтете ни одной страницы документации, и запустите систему хранения “энтером” (то есть просто тупо давя Enter на все вопросы, соглашаясь на все установки по умолчанию), то даже при сочетании самых нелепых решений, данные не будут повреждены и система будет, пусть неоптимально, но работать. В общем тот самый врачебный Noli Nocere! - “Не навреди!”. Реаллокация может быть не нужна в ряде профилей использования. Но даже когда она не нужна, а она запущена по умолчанию, и при этом вы об этом не знаете, она неизбежно занимает какую-то долю системных ресурсов, и лучше было бы, чтобы, если уж она запущена, то запущена она была “по делу”, и понимающим это человеком. </p>
<p>Вот поэтому по умолчанию, на свежеустановленной системе процесс <em>reallocation</em> не запущен автоматически и не работает.</p>
<p>Для того, чтобы понять, нужна ли вам <em>reallocation</em>, и какой эффект она вам даст, вам следует найти ответы на ряд вопросов, связанных с вашей системой и данными на ней хранящимися.</p>
<ol>
<li>Насколько сильно, в процентном отношении, заполнены активными, изменяющимися, а не просто хранящимися данными, заполнены диски, конкретнее - тома на aggregate?      </li>
<li>Каков процент свободного места на томах и aggregate? (помните, что WAFL – структура thin by design, и для нее 100% занятый пустыми томами aggregate – пустой)      </li>
<li>Насколько активно используется на томах deduplication, и сколько места она у вас высвобождает.      </li>
<li>Наконец, насколько часто вы расширяли тома и aggregate физическими дисками? </li>
</ol>
<p>На первые два вопроса ответ, и то как он соотносится с темой необходимости реаллокации, вы, скорее всего <a href="../881/trackback.html">уже знаете</a>. Если на диске в момент записи достаточно свободного места, то подсистема, выделяющая на диске место по запросу OS в форме дисковых <em>экстентов</em>, или протяженных сегментов блоков, с легкостью найдет и выделит процессу записи любое нужное количество блоков в единой цепочке. ??менно по этой причине в таких файловых системах, как ext2/3 и NTFS фрагментация файлов в самом деле принципиально ниже, чем в FAT, где OS не использует такое “групповое выделение” блоков, и занимает их по порядку, один за одним, не обращая внимание на то, где и как они расположены. Разумеется такой вариант, особенно в активной и, как это называется, <em>aged</em>, то есть давно используемой в работе файловой системе, вызывает существенное дробление фрагментов файла по диску.</p>
<p>Это не так в уже перечисленных “BSD-like” системах и NTFS. Пока на файловой системе есть достаточно свободного места, механизм выделения цепочек последовательных блоков работает хорошо. Сложности начинаются тогда, когда файловая система заполняется файлами, которые произвольно создаются и удаляются, и постепенно структура блоков данных начинает напоминать сыр с его дырками, когда вроде место и есть, но оно все “пузырьками”. Дело в том, что если последовательный экстент блоков нужной длины на дисковом томе найти не удается (а данные писать все ж таки надо), то описываемая подсистема OS говорит файловой системе: “ну ОК, давай мне два покороче, пусть в разных местах. Нету? Ну что-ж, ну а четыре еще короче есть?”. ?? такое <a href="../225/trackback.html">дробление</a> продолжается до тех пор, пока вся последовательность, ожидающая записи на диски не будет записана.</p>
<p>Очевидно, что чем меньше у файловой системы будет “пространства для маневра”, то есть последовательно свободного пространства на томе, и чем больше будет на этот том записей и перезаписей, тем сложнее ей будет&#160; с каждым разом&#160; находить связные последовательно куски блоков. ??менно по этой причине, например, Windows тревожно закрашивает красным диск, слишком сильно заполненным данными. Если это диск с файловой системой, которая не просто залита фильмами, как на скриншоте ниже, а активно обновляется, записывается и перезаписывается данными, то вскоре вы увидите, что коэффициент фрагментации файлов, ранее невысокий, на ней вдруг начнет резко расти, ухудшая ее характеристики производительности.</p>
<p><a href="/pics/Reallocation--Data-ONTAP_D3DC/image.png"><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="/pics/Reallocation--Data-ONTAP_D3DC/image_thumb.png" width="658" height="204" /></a></p>
<p>Напомню, что рекомендуется поддерживать 10-15% свободного места на томе и aggregate для нормальной работы описанных выше механизмов (это примерно совпадает с рекомендациями MS для NTFS), причем на уровне aggregate это пространство уже зарезервировано в WAFL reserve, недоступном пользователю.</p>
<p>Подводя итоги по этой части хочу специально указать: это <em>рекомендация</em>, но не <em>требование</em>. Вы МОЖЕТЕ заполнить диск данными на все 100% его емкости. ?? в ряде случаев, например как на картинке выше, где приведен скриншот моего лэптопа, и где выделенный диск есть хранилище бэкапов, фильмов и музыки, то есть записи на него нерандомны и крайне редки, это не имеет большого значения и мало влияет на его производительность.</p>
<p>Но если ваши данные активно перезаписываются, и у вас есть возможность не заливать их на том “с горкой”, то оставьте побольше свободного места на томе (и на aggregate для thin-томов) – не пожалеете :)</p>
<p>??так, чтобы не раздувать один пост, продолжим на следующей неделе.</p>
				</div>
		
				<div class="postmetadata">
					Метки: <a href="defragmentation.html" rel="tag">defragmentation</a>, <a href="fragmentation.html" rel="tag">fragmentation</a>, <a href="netapp/index.html" rel="tag">netapp</a>, <a href="reallocate.html" rel="tag">reallocate</a>, <a href="reallocation.html" rel="tag">reallocation</a><br />					Раздел: <a href="../category/techtalk/index.html" title="Просмотреть все записи в рубрике &laquo;techtalk&raquo;" rel="category tag">techtalk</a>&nbsp;&nbsp;|&nbsp;
					<a href="../1292/trackback.html#comments" title="Комментарий к записи Reallocation в Data ONTAP. Часть 1.">Комментарии (10)</a>									 </div>
			</div>
	
						
			<div class="post" id="post-1225">
				<h2 class="posttitle"><a href="../1225/trackback.html" rel="bookmark" title="Permanent Link to В последний раз о фрагментации файлов и производительности">В последний раз о фрагментации файлов и производительности</a></h2>
				<div class="postmetadata">23 Октябрь 2012, 10:56 <!-- от  --></div>
				<div class="postentry">
					<p>Я много раз в этом блоге трогал тему о влиянии фрагментации на производительность работы системы хранения (см. например <a href="../221/trackback.html">раз</a>, <a href="../225/trackback.html">два</a>, <a href="../881/trackback.html">три</a>). Но как-то все это были слова, а как насчет “покажь логи”? Так как я до недавних пор был “безлошадный”, а все мои знакомые “с оборудованием” все как на подбор были “ленивы и нелюбопытны”, чтобы дать документальный ответ на этот вопрос, то поэтому пришлось отвечать самому.</p>
<p>Тут вот, как вы уже заметили, я, наконец, <em>обзавелся на хозяйстве </em>маленьким нетаппчиком, и, пока мы его в продакшн не ввели, гоняю в хвост и в гриву, в том числе <em>отвечаю на назревшие вопросы</em>. ?? первый – о том, влияет ли фрагментация данных на производительность доступа к ним при рандомном характере доступа.</p>
<p>Выше в постах, на которые я сослался, я уже ответил на этот вопрос и прояснил свою позицию. Вкратце: <strong>при рандомном доступе производительность от фрагментации данных не зависит</strong>. Так как система хранения обращается к данным рандомно, в произвольном, случайном порядке, то нет никакой особенной разницы в том, будут ли блоки данных лежать упорядоченно, или беспорядочно – их всегда будут читать “беспорядочно”. А рандомность обращения, помноженная на рандомность размещения не дает “рандомность в квадрате”, она остается обычной рандомностью, “в первой степени”.</p>
<p>Надеюсь не нужно дополнительно объяснять, почему для современных многозадачных систем, для баз OLTP, для виртуализованных серверных сред почти 100% доступа к данным является рандомным? Последовательный, “секвентальный” доступ встречается в очень узком сегменте, это бэкапы (а у NetApp, к слову, задача бэкапа, как вы помните, решается другим способом, а не последовательным копированием и передачей данных), это базы с характером доступа DSS, и это, отчасти, логи баз данных. Вот, в общем, и все использование секвентального доступа. Остальное все – более или менее чистый рандом.</p>
<p>Поэтому я взял паттерн доступа <strong>VM-сервер</strong> (40%-write/60%-read, 45%-sequental/55%-random, 4KB block). Секвентальность в последнем случае берется вследствие работы локального кэша хоста. Паттерны эти определил не я, они довольно широко распространены. Вот его и будем <strike>кушать</strike> мерять.</p>
<p>Тестировал я с помощью IOmeter, который, несмотря на некоторые его недостатки, знаю и люблю. В качестве load-generator использовались виртуальные машины, работающие с достаточно мощного хоста (IBM 3850 X5), который был подключен к стораджу по NFS. Для OS в VM диск выглядел “физическим” LUN без файловой системы, который делался MBR-разделом и форматировался в NTFS со стандартным размером блока (4KB). Раздел делался размером 40GB, на нем создавался тестовый файл IOmeter (iobw.tst), размером 16GB (для гарантированного “пробоя кэша”). На каждой VM делался 4-процессорный vCPU, и, соответственно, запускались 4 Worker, на каждом из которых пускался тестовый паттерн на созданный диск, в 16 потоков ввода-вывода (Outstanding IOs) на каждый Worker, то есть 64 одновременных потока ввода-вывода на диски (контроллер NetApp). Загрузка хост-сервера тестом не превышала при этом 15% (мощная зверюга этот 3850), загрузка стораджа колебалась, но также не превышала 80%. То есть заведомо мы в “потолки” нигде не упирались.</p>
<p>Для минимизации эффектов “прогрева WAFL” (о котором еще будет пост, это также была одна из тем “исследовательской недели”) я делал длинный ramp-up (10 минут), а затем начинался собственно измеряемый тест, длиной 30 минут. Я брал для оценки значение в steady state, ближе к концу теста, и для оценки параллельно проверяемого эффекта “падения производительности” при прогреве – ближе к его началу.</p>
<p>Однако, перед исследователем, в моем лице, встала проблема: как обеспечить “фрагментацию” файла тестирования? Если создать последовательный, упорядоченный файл просто: запускай IOmeter на пустом диске – вот он и создаст свой iobw.tst, то с фрагментацией “на заказ” сложнее.</p>
<p>Для того, чтобы сделать фрагментированный файл я нашел любопытную утилитку, под названием MyDefragmenter, которая, как ясно из названия – дефрагментатор. Но у нее в комплекте есть также программка MyFragmenter :). Она делает вполне ожидаемую из названия вещь :)</p>
<p>Я взял созданный IOmeter тестовый файл и <em>качественно замесил</em> его с помощью этой утилитки. Я фрагментировал с ее помощью этот файл на 250 тысяч кусочков по 64KB каждый (ну, чтоб не было претензий, что <em>гранаты у нас не той системы</em>;), а потом повторно провел тестирование описанными выше паттернами.</p>
<p>Также я проанализировал ситуацию с фрагментацией не только файла на NTFS, но и в WAFL, а затем измерил эффект от работы reallocate в WAFL.</p>
<p>Хочу отдельно отметить, что в данном случае измеренные “попугаи”&#160; не могут рассматриваться по абсолютной величине, я не проводил никакого (необходимого) тюнинга системы, и настройки ее “по уму” и по best practices (это я&#160; сделаю позже, ту у меня есть некоторые бюрократические процедуры для этого). Целью теста было сравнить два достигнутых параметра производительности: “А” и”Б”, то есть их соотношение, а не достижение абсолютного рекорда, поэтому реплики с мест “чота как-то иопсев маловата!” мы отметем как неорганизованные ;).</p>
<p>Вот какие результаты я получил:</p>
<p>   <a href="../1225/trackback.html#more-1225" class="more-link"><small>Continue reading &#8216;В последний раз о фрагментации файлов и производительности&#8217; &raquo;</small></a></p>
				</div>
		
				<div class="postmetadata">
					Метки: <a href="fragmentation.html" rel="tag">fragmentation</a>, <a href="netapp/index.html" rel="tag">netapp</a>, <a href="performance/index.html" rel="tag">performance</a>, <a href="reallocate.html" rel="tag">reallocate</a>, <a href="wafl/index.html" rel="tag">wafl</a><br />					Раздел: <a href="../category/justread/index.html" title="Просмотреть все записи в рубрике &laquo;justread&raquo;" rel="category tag">justread</a>,  <a href="../category/techtalk/index.html" title="Просмотреть все записи в рубрике &laquo;techtalk&raquo;" rel="category tag">techtalk</a>&nbsp;&nbsp;|&nbsp;
					<a href="../1225/trackback.html#comments" title="Комментарий к записи В последний раз о фрагментации файлов и производительности">Комментарии (13)</a>									 </div>
			</div>
	
						
			<div class="post" id="post-881">
				<h2 class="posttitle"><a href="../881/trackback.html" rel="bookmark" title="Permanent Link to Откуда вообще берется фрагментация?">Откуда вообще берется фрагментация?</a></h2>
				<div class="postmetadata">21 Апрель 2011, 8:00 <!-- от  --></div>
				<div class="postentry">
					<p>Так что же там на самом деле происходит с фрагментацией на NetApp?</p>
<p>Давайте, для начала, разберемся с основами. Я в этом блоге уже не раз писал о проблеме фрагментации, и желающих сошлю в более ранние посты, например <a href="../221/trackback.html">сюда</a> и <a href="../225/trackback.html">сюда</a>.</p>
<p>К сожалению тема фрагментации данных на WAFL до сих пор остается в некотором роде <a href="http://dic.academic.ru/dic.nsf/enc3p/333174">эзотерическим</a> знанием. Связано это, в первую очередь с тем, как мне представляется, что рассказ о фрагментации и необходимом противодействии ему, затрагивает ряд чувствительных особенностей функционирования WAFL, деталях, которые NetApp, по разным причинам (совсем не обязательно злонамеренным), разглашать пока не хочет.</p>
<p>Поэтому официальная позиция состоит в рекомендации, в случае, если влияние фрагментации в вашем конкретном случае, проявляется негативно (она, кстати, может и не проявляться), то включать wafl reallocate ( <code>reallocate on / reallocate start [/vol/volname]</code>) и спать счастливо.</p>
<p>Вообще же FUD вокруг <em>non-contiguous wafl blocks allocation</em> построен (впрочем, как и почти любой FUD) вокруг плохого представления технических деталей процесса и иногда чистосердечного, а чаще злонамеренного “непонимания” этих деталей. Давайте, для начала, разберем как же записываются данные в WAFL, по крайней мере на том уровне, на котором нам этот процесс показывает NetApp.</p>
<p>Но начать придется издалека.</p>
<p>   <a href="../881/trackback.html#more-881" class="more-link"><small>Continue reading &#8216;Откуда вообще берется фрагментация?&#8217; &raquo;</small></a></p>
				</div>
		
				<div class="postmetadata">
					Метки: <a href="fragmentation.html" rel="tag">fragmentation</a>, <a href="fud/index.html" rel="tag">fud</a>, <a href="netapp/index.html" rel="tag">netapp</a>, <a href="wafl/index.html" rel="tag">wafl</a><br />					Раздел: <a href="../category/techtalk/index.html" title="Просмотреть все записи в рубрике &laquo;techtalk&raquo;" rel="category tag">techtalk</a>&nbsp;&nbsp;|&nbsp;
					<a href="../881/trackback.html#comments" title="Комментарий к записи Откуда вообще берется фрагментация?">Комментарии (12)</a>									 </div>
			</div>
	
						
			<div class="post" id="post-874">
				<h2 class="posttitle"><a href="../874/trackback.html" rel="bookmark" title="Permanent Link to О &ldquo;дефрагментации&rdquo;">О &ldquo;дефрагментации&rdquo;</a></h2>
				<div class="postmetadata">11 Апрель 2011, 8:00 <!-- от  --></div>
				<div class="postentry">
					<p>“Усилиями” наших конкурентов все нынешние и будущие пользователи NetApp проинформированы, что “у этих netapp”, дескать, “огромная фрагментация”. Как обычно в области FUD (<a href="http://en.wikipedia.org/wiki/Fear,_uncertainty_and_doubt">Fear, uncertainty and doubt</a>), строится это все вокруг плохого понимания предмета, слабой технической подготовки “обрабатываемого”, а порой и откровенной манипуляции фактами. Отсутствие же ясного понимания темы, к сожалению, вызывает к жизни довольно много “техномистицизма” и накрученных вокруг догадок и слухов, которые, как и положено слухам, кормят и размножают сами себя.</p>
<p>В четверг я опубликую заметку о “теории” возникновения фрагментации на дисках вообще, интересующиеся отсылаются в нее. А пока хотел лишь обратить внимание читателей на прискорбную тенденцию, с которой встречаюсь уже не впервой.</p>
<p>Пользователи NetApp, которые не особенно копенгаген в технических деталях, но которым надули в уши про “ужасную фрагментацию на NetApp”, считают, что раз что-то на NetApp, значит это что-то надо “дефрагментировать”, и чем чаще, тем лучше. Причем под “дефрагментировать” обычно понимается виндовый defrag.exe, или же еще какой Diskeeper.&#160; <br />Прискорбное заблуждение.</p>
<p>Еще более прискорбным оно становится, если дело происходит на диске виртуальной машины.</p>
<p>Если вы внимательно прочли наш <a href="http://www.netwell.ru/production/techbiblioteka.php">переводной Best Practices</a> по работе с <a href="../789/trackback.html">VMware</a> или <a href="../570/trackback.html">Hyper-V</a>,то должны были обратить внимание на строгое указание не использовать дефрагментатор OS на дисках, расположенных на системе хранения NetApp, будь то iSCSI/FC LUN, смонтированный на сервер, или же VHD/vmdk виртуальной машины.</p>
<p>Дело в том, что дефрагментатор в OS, это программа, которая ничего не знает о той, часто непростой структуре, что лежит под тем, что она считает “обычным жестким диском”. Она видит нечто (LUN), которое представляется ей обычным жестким диском, с секторами, головками и цилиндрами, но в случае LUN все это не имеет настоящего физического смысла. Под таким “псевдо-диском” могут лежать структуры RAID, или те или иные структуры организации его физических блоков (в случае NetApp – WAFL, в случае других систем, других вендоров – другие структуры) . На этом уровне работает непростая&#160; дорогостоящая логика оптимизации доступа в больших системах хранения, которая знает как, и умеет оптимизировать доступ к своим данным. ?? вмешательство в эту логику примитивной “дефрагментации” на уровне OS не только бессмысленно, но и нежелательно. ?? уж точно никак с помощью defrag.exe не справиться с проблемой “фрагментации данных на NetApp”, ситуацию можно только ухудшить.</p>
<p>В случае конкретно NetApp, выполнение “дефрагментации” на уровне клиентской OS или виртуальной машины:</p>
<ol>
<li>Резко увеличивает объемы, занимаемые снэпшотами, так как пространство диска на NetApp со взятым снэпшотом занимает только изменения (записи), сделанные на нем после создания снэпшота, а “дефрагментация” при работе перезаписывает почти весь диск, то вы обнаружите, что снэпшот после такой “дефрагментации” практически удвоит занимаемое вашим томом на дисках место </li>
<li>Портит оптимизацию доступа на уровне системы хранения, так как то, что, по мнению дефрагментатора, лежит рядом и последовательно, физически, на уровне системы хранения, и собственно физических дисков, может лежать совсем НЕ рядом и НЕ последовательно, и наоборот. </li>
<li>Замусоривает кэш и загружает канал ввода-вывода бессмысленными операциями. </li>
</ol>
<p>?? в итоге – не приводит ни к чему, так как “фрагментацию” на уровне самого NetApp так не исправить, скорее наоборот, многочисленными перезаписями ее можно только ухудшить.</p>
<p>Если вы все равно не осилили все написанное выше, то просто следуйте простым советам:</p>
<ul>
<li><strong>Не используйте дефрагментацию в OS</strong> (defrag.exe, Diskeeper, Norton Defrag, etc.) для данных, расположенных на системе хранения NetApp. В том числе отключите автоматическую оптимизацию (Boot Time Optimization) и фоновую дефрагментацию дисков в OS Windows. </li>
<li>Не обращайте внимания на величины “фрагментации”, указываемые самой OS для LUN-ов и дисков виртуальных машин, размещенных на NetApp. </li>
<li>Для минимизации эффекта фрагментации записи непосредственно на дисках системы хранения NetApp используйте включение по расписанию встроенный в Data ONTAP реаллокатор (reallocate on / reallocate start [/vol/volname]). </li>
</ul>
<p>&#160;</p>
<p>&#160;</p>
<p><font color="#cccccc">ЗЫ. Вообще писалось все это смешно. Я сел а ноут, написал заголовок: “Несколько слов о дефрагментации”, и начал писать. Спустя два часа и примерно к конце третьего килобайта написанного я остановился, хмыкнул, посмотрел на заголовок… ?? удалил из него “Несколько слов”, так как на “несколько слов” получающийся трактат никак не тянул. :)      <br />В конце концов я решил разделить тему. В первую часть вынести все же “несколько слов”, те, которые и намеревался написать, а в четверговый пост пустить всю остальную “теорию большого взрыва”, которую, возможно, кому-то захочется прочитать, чтобы разобраться в деталях темы.</font></p>
				</div>
		
				<div class="postmetadata">
					Метки: <a href="fragmentation.html" rel="tag">fragmentation</a>, <a href="netapp/index.html" rel="tag">netapp</a>, <a href="reallocate.html" rel="tag">reallocate</a>, <a href="wafl/index.html" rel="tag">wafl</a><br />					Раздел: <a href="../category/techtalk/index.html" title="Просмотреть все записи в рубрике &laquo;techtalk&raquo;" rel="category tag">techtalk</a>&nbsp;&nbsp;|&nbsp;
					<a href="../874/trackback.html#comments" title="Комментарий к записи О &ldquo;дефрагментации&rdquo;">Комментарии (3)</a>									 </div>
			</div>
	
						
			<div class="post" id="post-466">
				<h2 class="posttitle"><a href="../466/trackback.html" rel="bookmark" title="Permanent Link to Еще о фрагментации">Еще о фрагментации</a></h2>
				<div class="postmetadata">23 Ноябрь 2009, 8:00 <!-- от  --></div>
				<div class="postentry">
					<p>Несколько слов о теме влияния фрагментации данных на скорость доступа к ним, которую я начал в прошлый понедельник заметкой о теоретической модели, показывающей сравнительно малое влияние фрагментации на случайный (random) по характеру доступ.</p>
<p>Однако как обстоят дела с последовательным (sequental) доступом, ведь такой тоже имеет место быть (пример – записи в лог базы данных)? Очевидно, что тут-то и должна проявиться в полный рост проблема фрагментации, и ее влияния на производительность.</p>
<p>В блогах я нашел описание <a href="http://sqlblog.com/blogs/linchi_shea/archive/2008/12/22/performance-impact-file-fragmentation-and-san-part-v.aspx">любопытного эксперимента</a> (по ссылке часть 5, смотрите в тексте ссылки на предыдущие 4 части).</p>
<p>Автор создавал сильно фрагментированный, кусками по 2MB и 128KB (5000 и 60000 кусков соответственно), файл, общим размером 10GB, и тестировал на нем последовательные чтения и записи. В качестве дискового хранилища использовались как диски самого сервера (на графиках - DAS), так и раздел на SAN-хранилище EMC Symmetrix DMX-2.</p>
<p>Вот как описывает тестовое оборудование сам автор: <em>The server was a standard DL580 with 4 single-core sockets (2.0GHz Xeon) with 4GB of RAM. The disk array was a DMX2 with 10K rpm 146GB FC drives in a RAID10 config. The test LUN was 96GB in size (with 8GB disk slices from 24 spindles). Two Emulex LP8000 HBAs were load balanced with PowerPath.</em></p>
<p><a href="/pics//image19.png"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="/pics//image-thumb7.png" width="437" height="286" /></a> </p>
<p>Первый результат был обескураживающим. В случае использования высокопроизводительного SAN-стораджа, результаты для фрагментированного и дефрагментированного файла, и тестирования последовательной записи блоками по 1К,&#160; были практически идентичными. Очевидно, что эффективное кэширование и хороший запас быстродействия DMX “съели” возможное снижение быстродействия из за присутствия фрагментов.</p>
<p>Далее автор создал аналогичный раздел на дисках серверов (DAS), и протестировал его.</p>
<p><a href="/pics//image20.png"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="/pics//image-thumb8.png" width="542" height="273" /></a>&#160; </p>
<p>?? тут мы уже видим значительный эффект от фрагментированности файла при <strong>последовательном</strong> доступе (почти 30% снижение быстродействия).</p>
<p>Далее автор уменьшил размеры “блоков фрагментации” до 128KB (то есть увеличил количество фрагментов своего 10GB тестового файла), и проверил эффект на последовательном чтении. </p>
<p><a href="/pics//image21.png"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="/pics//image-thumb9.png" width="575" height="546" /></a> </p>
<p>?? снова мы видим, что эффект хорошо заметный на DAS, практически отсутствует на высокопроизводительном SAN-массиве.</p>
<p>Проявляется ли хоть как-то эффект от фрагментации вообще? Автор обнаружил лишь один параметр:</p>
<p><a href="/pics//image22.png"><img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="image" border="0" alt="image" src="/pics//image-thumb10.png" width="565" height="275" /></a> </p>
<p>На файле размером в 10GB, состоящим из 60 тысяч хаотически разбросанных по диску фрагментов заметно выросло время Latency, задержек чтения. Обратите внимание, что для такого же 10GB-файла с 2MB блоками, разбитого на 5000 таких же разбросанных фрагментов, не было даже и такого эффекта.</p>
<p>??, наконец, автор измерил время ряда операций:</p>
<p><a href="/pics//image23.png"><img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="image" border="0" alt="image" src="/pics//image-thumb11.png" width="567" height="775" /></a> </p>
</p>
<p>В заключение этого поста я хотел бы особо обратить внимание читателя вот на что. Целью поста является не отрицание влияния фрагментации на производительность чтения-записи при <em>последовательном</em> доступе. Уверен, в любом случае можно подобрать такое сочетание режима доступа, размеров файла и блоков чтения, что этот эффект будет отчетливо проявлен.     <br />Однако я хотел бы привлечь внимание читателей к тому факту, что, зачастую, негативный эффект фрагментации на производительность <strong>в реальной жизни</strong>, в вашем конкретном случае, и на современных производительных системах хранения, зачастую необъективно переоценивается и ей придается значительно больше значения, чем присутствует на самом деле.     <br />??з приведенных результатов вы видите, например, что даже на последовательном, наиболее страдающем при фрагментации режиме, на высокопроизводительном сторадже влияние фрагментации, в случае конфигурации, тестируемой автором цитированного поста, практически ничтожно.</p>
				</div>
		
				<div class="postmetadata">
					Метки: <a href="fragmentation.html" rel="tag">fragmentation</a><br />					Раздел: <a href="../category/techtalk/index.html" title="Просмотреть все записи в рубрике &laquo;techtalk&raquo;" rel="category tag">techtalk</a>&nbsp;&nbsp;|&nbsp;
					<a href="../466/trackback.html#respond" title="Комментарий к записи Еще о фрагментации">Комментарий</a>									 </div>
			</div>
	
						
			<div class="post" id="post-455">
				<h2 class="posttitle"><a href="../455/trackback.html" rel="bookmark" title="Permanent Link to Влияет ли фрагментация данных на скорость random-доступа?">Влияет ли фрагментация данных на скорость random-доступа?</a></h2>
				<div class="postmetadata">16 Ноябрь 2009, 9:30 <!-- от  --></div>
				<div class="postentry">
					<p>Одной из вечных тем FUD-а конкурентов NetApp является “проблема” с фрагментаций данных в WAFL.    <br />Оставим сейчас в стороне вопрос, насколько фрагментация действительно проявляется в практической жизни (я на эту тему уже <a href="../225/trackback.html">писал ранее</a>). Рассмотрим только вопрос того, насколько такой эффект вообще имеет место быть в теории. </p>
<p>Алекс Макдональд, инженер NetApp, в своем блоге привел <a href="http://blogs.netapp.com/shadeofblue/2009/09/random-rocks-and-benchmarks.html">любопытную модель</a>, оценивающую влияние фрагментации на эффективность, в случае случайного (random) по характеру доступа.</p>
<p>Он заполнил таблицу из ста строк сотней случайных чисел, взятых с random.org, в первом столбце, которые изображают фрагментированные данные, затем второй столбец также случайными числами, изображающими то, какой блок программа запросила, в случае рандомного доступа к данным. ?? наконец он сравнил суммарное расстояние “seek” в случае считывания запрошенных данных (второй столбец) из максимально фрагментированного массива (первый столбец) и упорядоченного (то есть просто от 1 до 100).</p>
<table border="1" cellspacing="2" cellpadding="2" width="636">
<tbody>
<tr>
<td valign="top" width="134">
<p><strong>Random Placement</strong></p>
</td>
<td valign="top" width="158">
<p><strong>Random Requested Block</strong></p>
</td>
<td valign="top" width="171">
<p><strong>Matching Block (Random Placement)</strong></p>
</td>
<td valign="top" width="135">
<p><strong>Seek Distance (Random Placement)</strong></p>
</td>
<td valign="top" width="139">
<p><strong>Seek Distance (Sequential Placement)</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="134">67</td>
<td valign="top" width="158">80</td>
<td valign="top" width="171">22</td>
<td valign="top" width="135">0</td>
<td valign="top" width="139">0</td>
</tr>
<tr>
<td valign="top" width="134">19</td>
<td valign="top" width="158">37</td>
<td valign="top" width="171">58</td>
<td valign="top" width="135">36</td>
<td valign="top" width="139">43</td>
</tr>
<tr>
<td valign="top" width="134">75</td>
<td valign="top" width="158">18</td>
<td valign="top" width="171">61</td>
<td valign="top" width="135">3</td>
<td valign="top" width="139">19</td>
</tr>
<tr>
<td valign="top" width="134">23</td>
<td valign="top" width="158">26</td>
<td valign="top" width="171">53</td>
<td valign="top" width="135">8</td>
<td valign="top" width="139">8</td>
</tr>
<tr>
<td valign="top" width="134">85</td>
<td valign="top" width="158">57</td>
<td valign="top" width="171">63</td>
<td valign="top" width="135">10</td>
<td valign="top" width="139">31</td>
</tr>
<tr>
<td valign="top" width="134">59</td>
<td valign="top" width="158">100</td>
<td valign="top" width="171">14</td>
<td valign="top" width="135">49</td>
<td valign="top" width="139">43</td>
</tr>
<tr>
<td valign="top" width="134">14</td>
<td valign="top" width="158">59</td>
<td valign="top" width="171">6</td>
<td valign="top" width="135">8</td>
<td valign="top" width="139">41</td>
</tr>
<tr>
<td valign="top" width="134">&#8230;</td>
<td valign="top" width="158">&#8230;</td>
<td valign="top" width="171">&#8230;</td>
<td valign="top" width="135">&#8230;</td>
<td valign="top" width="139">&#8230;</td>
</tr>
<tr>
<td valign="top" width="134">
<p><strong>SUM</strong></p>
</td>
<td valign="top" width="158">&#160;</td>
<td valign="top" width="171">&#160;</td>
<td valign="top" width="135">
<p><strong>3269</strong></p>
</td>
<td valign="top" width="139"><strong>3322</strong></td>
</tr>
</tbody>
</table>
<p>С точки зрения “здравого смысла” мы бы ожидали, что фрагментированный столбец даст значительно (или хотя бы заметно) большую величину “seek”, по сравнению с упорядоченным, однако этого не произошло! Более того, столбец со случайно заполненными данными, из которого столь же случайно “запрашиваются” числа имел даже чуть меньший “seek” чем полностью упорядоченный! (Впрочем, ясно видно, что на достаточно большом интервале эти числа будут стремиться сравняться, так что можно просто принять их равными).</p>
<p>Несколько неожиданный для “здравого смысла” результат, однако, поразмыслив, нельзя не признать его правильным. “Случайное” помноженное на “случайное”&#160; не дает “случайное в квадрате”. :)</p>
<p>Отсюда немного парадоксальный вывод: В случае случайного (random) по характеру доступа к данным, а именно такой тип нагрузки обычно и принято тестировать в первую очередь, так как он наилучшим образом соответствует работе современных многозадачных серверных систем и баз данных OLTP, фрагментация (случайность их размещения) данных на диске практически не увеличивает количество “вредоносного” seek distance по сравнению со случайным чтением упорядоченных данных, и не ухудшает характеристики производительности!</p>
				</div>
		
				<div class="postmetadata">
					Метки: <a href="fragmentation.html" rel="tag">fragmentation</a>, <a href="justread.html" rel="tag">justread</a>, <a href="netapp/index.html" rel="tag">netapp</a>, <a href="techtalk/index.html" rel="tag">techtalk</a><br />					Раздел: <a href="../category/justread/index.html" title="Просмотреть все записи в рубрике &laquo;justread&raquo;" rel="category tag">justread</a>,  <a href="../category/techtalk/index.html" title="Просмотреть все записи в рубрике &laquo;techtalk&raquo;" rel="category tag">techtalk</a>&nbsp;&nbsp;|&nbsp;
					<a href="../455/trackback.html#respond" title="Комментарий к записи Влияет ли фрагментация данных на скорость random-доступа?">Комментарий</a>									 </div>
			</div>
	
						
			<div class="post" id="post-191">
				<h2 class="posttitle"><a href="../191/trackback.html" rel="bookmark" title="Permanent Link to О измерении производительности.">О измерении производительности.</a></h2>
				<div class="postmetadata">8 Декабрь 2008, 8:00 <!-- от  --></div>
				<div class="postentry">
					<p>Любопытный отчет о <a href="../37/trackback.html">тестировании систем NetApp с помощью iometer</a>.<br />
Подробно рассмотрены некоторые важные аспекты процесса, в том числе приведен паттерн, на которых проводилось тестирование (симулировалась загрузка типа производимой Exchange 2003).<br />
В целом все довольно схоже с <a href="../26/trackback.html">моими результатами</a>, которые я делал в прошлом году, да и выбранная методика в целом похожа.</p>
<p><a href="http://blog.avanadeadvisor.com/blogs/patc/archive/2008/11/10/12107.aspx">Часть 1.</a></p>
<p><a href="http://blog.avanadeadvisor.com/blogs/patc/archive/2008/11/23/12133.aspx">Часть 2.</a></p>
<p>Тестировались FAS3070 и FAS2050.<br />
Обратите внимание, что автор специально готовил фрагментированные разделы, чтобы приблизить результаты к реальным условиям эксплуатации.<br />
??змерены и приведены результаты для различных показателей фрагментации.</p>
				</div>
		
				<div class="postmetadata">
					Метки: <a href="fas2050.html" rel="tag">fas2050</a>, <a href="fas3070.html" rel="tag">fas3070</a>, <a href="fragmentation.html" rel="tag">fragmentation</a>, <a href="iometer.html" rel="tag">iometer</a>, <a href="ms-exchange.html" rel="tag">ms exchange</a>, <a href="netapp/index.html" rel="tag">netapp</a>, <a href="performance/index.html" rel="tag">performance</a><br />					Раздел: <a href="../category/news/index.html" title="Просмотреть все записи в рубрике &laquo;новости&raquo;" rel="category tag">новости</a>&nbsp;&nbsp;|&nbsp;
					<a href="../191/trackback.html#comments" title="Комментарий к записи О измерении производительности.">Комментарии (2)</a>									 </div>
			</div>
	
		
		<div class="navigation">
			<div class="alignleft"></div>
			<div class="alignright"></div>
		</div>
		
	
	</div>
	<div id="sidebar">
		<ul>
			
			
			<!-- Author information is disabled per default. Uncomment and fill in your details if you want to use it.
			<li><h2>Автор</h2>
			<p>A little something about you, the author. Nothing lengthy, just an overview.</p>
			</li>
			-->

			<li class="pagenav"><h2>Страницы</h2><ul><li class="page_item page-item-153"><a href="../../about/trackback.html" title="about">about</a></li>
<li class="page_item page-item-215"><a href="../../distributory-v-rossii/trackback.html" title="Дистрибуторы в России">Дистрибуторы в России</a></li>
<li class="page_item page-item-1327"><a href="../../disti-ua/trackback.html" title="Дистрибуторы в Украине">Дистрибуторы в Украине</a></li>
</ul></li>
			<li><h2>Рубрики</h2>
				<ul>
					<li class="cat-item cat-item-89"><a href="../category/commands/index.html" title="Просмотреть все записи в рубрике &laquo;commands&raquo;">commands</a>
</li>
	<li class="cat-item cat-item-37"><a href="../category/howto/index.html" title="Просмотреть все записи в рубрике &laquo;howto&raquo;">howto</a>
</li>
	<li class="cat-item cat-item-52"><a href="../category/justread/index.html" title="Просмотреть все записи в рубрике &laquo;justread&raquo;">justread</a>
</li>
	<li class="cat-item cat-item-51"><a href="../category/review/index.html" title="Просмотреть все записи в рубрике &laquo;review&raquo;">review</a>
</li>
	<li class="cat-item cat-item-3"><a href="../category/techtalk/index.html" title="Просмотреть все записи в рубрике &laquo;techtalk&raquo;">techtalk</a>
</li>
	<li class="cat-item cat-item-71"><a href="../category/tricks/index.html" title="Просмотреть все записи в рубрике &laquo;tricks&raquo;">tricks</a>
</li>
	<li class="cat-item cat-item-95"><a href="../category/utilities/index.html" title="Просмотреть все записи в рубрике &laquo;utilities&raquo;">utilities</a>
</li>
	<li class="cat-item cat-item-44"><a href="../category/whoisho/index.html" title="Просмотреть все записи в рубрике &laquo;whoisho&raquo;">whoisho</a>
</li>
	<li class="cat-item cat-item-1"><a href="../category/news/index.html" title="Просмотреть все записи в рубрике &laquo;новости&raquo;">новости</a>
</li>
	<li class="cat-item cat-item-387"><a href="../category/opros.html" title="Просмотреть все записи в рубрике &laquo;опрос&raquo;">опрос</a>
</li>
	<li class="cat-item cat-item-8"><a href="../category/translations/index.html" title="Просмотреть все записи в рубрике &laquo;переводы&raquo;">переводы</a>
</li>
	<li class="cat-item cat-item-40"><a href="../category/citaty/index.html" title="Просмотреть все записи в рубрике &laquo;цитаты&raquo;">цитаты</a>
</li>
				</ul>
			</li>

			<li><h2>Архивы</h2>
				<ul>
					<li><a href='../date/2018/01.html' title='Январь 2018'>Январь 2018</a></li>
	<li><a href='../date/2015/10.html' title='Октябрь 2015'>Октябрь 2015</a></li>
	<li><a href='../date/2015/04.html' title='Апрель 2015'>Апрель 2015</a></li>
	<li><a href='../date/2015/03.html' title='Март 2015'>Март 2015</a></li>
	<li><a href='../date/2015/01.html' title='Январь 2015'>Январь 2015</a></li>
	<li><a href='../date/2014/12.html' title='Декабрь 2014'>Декабрь 2014</a></li>
	<li><a href='../date/2014/11.html' title='Ноябрь 2014'>Ноябрь 2014</a></li>
	<li><a href='../date/2014/10.html' title='Октябрь 2014'>Октябрь 2014</a></li>
	<li><a href='../date/2014/09.html' title='Сентябрь 2014'>Сентябрь 2014</a></li>
	<li><a href='../date/2014/08.html' title='Август 2014'>Август 2014</a></li>
	<li><a href='../date/2014/07.html' title='Июль 2014'>Июль 2014</a></li>
	<li><a href='../date/2014/06.html' title='Июнь 2014'>Июнь 2014</a></li>
	<li><a href='../date/2014/05.html' title='Май 2014'>Май 2014</a></li>
	<li><a href='../date/2014/04.html' title='Апрель 2014'>Апрель 2014</a></li>
	<li><a href='../date/2014/03.html' title='Март 2014'>Март 2014</a></li>
	<li><a href='../date/2014/02.html' title='Февраль 2014'>Февраль 2014</a></li>
	<li><a href='../date/2014/01.html' title='Январь 2014'>Январь 2014</a></li>
	<li><a href='../date/2013/12.html' title='Декабрь 2013'>Декабрь 2013</a></li>
	<li><a href='../date/2013/11.html' title='Ноябрь 2013'>Ноябрь 2013</a></li>
	<li><a href='../date/2013/10.html' title='Октябрь 2013'>Октябрь 2013</a></li>
	<li><a href='../date/2013/09.html' title='Сентябрь 2013'>Сентябрь 2013</a></li>
	<li><a href='../date/2013/08.html' title='Август 2013'>Август 2013</a></li>
	<li><a href='../date/2013/07.html' title='Июль 2013'>Июль 2013</a></li>
	<li><a href='../date/2013/06.html' title='Июнь 2013'>Июнь 2013</a></li>
	<li><a href='../date/2013/05.html' title='Май 2013'>Май 2013</a></li>
	<li><a href='../date/2013/04.html' title='Апрель 2013'>Апрель 2013</a></li>
	<li><a href='../date/2013/03.html' title='Март 2013'>Март 2013</a></li>
	<li><a href='../date/2013/02.html' title='Февраль 2013'>Февраль 2013</a></li>
	<li><a href='../date/2013/01.html' title='Январь 2013'>Январь 2013</a></li>
	<li><a href='../date/2012/12.html' title='Декабрь 2012'>Декабрь 2012</a></li>
	<li><a href='../date/2012/11.html' title='Ноябрь 2012'>Ноябрь 2012</a></li>
	<li><a href='../date/2012/10.html' title='Октябрь 2012'>Октябрь 2012</a></li>
	<li><a href='../date/2012/09.html' title='Сентябрь 2012'>Сентябрь 2012</a></li>
	<li><a href='../date/2012/08.html' title='Август 2012'>Август 2012</a></li>
	<li><a href='../date/2012/07.html' title='Июль 2012'>Июль 2012</a></li>
	<li><a href='../date/2012/06.html' title='Июнь 2012'>Июнь 2012</a></li>
	<li><a href='../date/2012/05.html' title='Май 2012'>Май 2012</a></li>
	<li><a href='../date/2012/04.html' title='Апрель 2012'>Апрель 2012</a></li>
	<li><a href='../date/2012/03.html' title='Март 2012'>Март 2012</a></li>
	<li><a href='../date/2012/02.html' title='Февраль 2012'>Февраль 2012</a></li>
	<li><a href='../date/2012/01.html' title='Январь 2012'>Январь 2012</a></li>
	<li><a href='../date/2011/12.html' title='Декабрь 2011'>Декабрь 2011</a></li>
	<li><a href='../date/2011/11.html' title='Ноябрь 2011'>Ноябрь 2011</a></li>
	<li><a href='../date/2011/10/index.html' title='Октябрь 2011'>Октябрь 2011</a></li>
	<li><a href='../date/2011/09/index.html' title='Сентябрь 2011'>Сентябрь 2011</a></li>
	<li><a href='../date/2011/08.html' title='Август 2011'>Август 2011</a></li>
	<li><a href='../date/2011/07/index.html' title='Июль 2011'>Июль 2011</a></li>
	<li><a href='../date/2011/06/index.html' title='Июнь 2011'>Июнь 2011</a></li>
	<li><a href='../date/2011/05/index.html' title='Май 2011'>Май 2011</a></li>
	<li><a href='../date/2011/04/index.html' title='Апрель 2011'>Апрель 2011</a></li>
	<li><a href='../date/2011/03/index.html' title='Март 2011'>Март 2011</a></li>
	<li><a href='../date/2011/02.html' title='Февраль 2011'>Февраль 2011</a></li>
	<li><a href='../date/2011/01.html' title='Январь 2011'>Январь 2011</a></li>
	<li><a href='../date/2010/12.html' title='Декабрь 2010'>Декабрь 2010</a></li>
	<li><a href='../date/2010/11/index.html' title='Ноябрь 2010'>Ноябрь 2010</a></li>
	<li><a href='../date/2010/10/index.html' title='Октябрь 2010'>Октябрь 2010</a></li>
	<li><a href='../date/2010/09/index.html' title='Сентябрь 2010'>Сентябрь 2010</a></li>
	<li><a href='../date/2010/08.html' title='Август 2010'>Август 2010</a></li>
	<li><a href='../date/2010/07/index.html' title='Июль 2010'>Июль 2010</a></li>
	<li><a href='../date/2010/06.html' title='Июнь 2010'>Июнь 2010</a></li>
	<li><a href='../date/2010/05.html' title='Май 2010'>Май 2010</a></li>
	<li><a href='../date/2010/04/index.html' title='Апрель 2010'>Апрель 2010</a></li>
	<li><a href='../date/2010/03/index.html' title='Март 2010'>Март 2010</a></li>
	<li><a href='../date/2010/02.html' title='Февраль 2010'>Февраль 2010</a></li>
	<li><a href='../date/2010/01.html' title='Январь 2010'>Январь 2010</a></li>
	<li><a href='../date/2009/12/index.html' title='Декабрь 2009'>Декабрь 2009</a></li>
	<li><a href='../date/2009/11/index.html' title='Ноябрь 2009'>Ноябрь 2009</a></li>
	<li><a href='../date/2009/10.html' title='Октябрь 2009'>Октябрь 2009</a></li>
	<li><a href='../date/2009/09.html' title='Сентябрь 2009'>Сентябрь 2009</a></li>
	<li><a href='../date/2009/08/index.html' title='Август 2009'>Август 2009</a></li>
	<li><a href='../date/2009/07/index.html' title='Июль 2009'>Июль 2009</a></li>
	<li><a href='../date/2009/06.html' title='Июнь 2009'>Июнь 2009</a></li>
	<li><a href='../date/2009/05.html' title='Май 2009'>Май 2009</a></li>
	<li><a href='../date/2009/04.html' title='Апрель 2009'>Апрель 2009</a></li>
	<li><a href='../date/2009/03.html' title='Март 2009'>Март 2009</a></li>
	<li><a href='../date/2009/02.html' title='Февраль 2009'>Февраль 2009</a></li>
	<li><a href='../date/2009/01.html' title='Январь 2009'>Январь 2009</a></li>
	<li><a href='../date/2008/12.html' title='Декабрь 2008'>Декабрь 2008</a></li>
	<li><a href='../date/2008/11.html' title='Ноябрь 2008'>Ноябрь 2008</a></li>
	<li><a href='../date/2008/10.html' title='Октябрь 2008'>Октябрь 2008</a></li>
	<li><a href='../date/2008/09.html' title='Сентябрь 2008'>Сентябрь 2008</a></li>
	<li><a href='../date/2008/08.html' title='Август 2008'>Август 2008</a></li>
	<li><a href='../date/2008/03.html' title='Март 2008'>Март 2008</a></li>
	<li><a href='../date/2008/02.html' title='Февраль 2008'>Февраль 2008</a></li>
	<li><a href='../date/2007/12.html' title='Декабрь 2007'>Декабрь 2007</a></li>
	<li><a href='../date/2007/11.html' title='Ноябрь 2007'>Ноябрь 2007</a></li>
	<li><a href='../date/2007/10.html' title='Октябрь 2007'>Октябрь 2007</a></li>
	<li><a href='../date/2007/09.html' title='Сентябрь 2007'>Сентябрь 2007</a></li>
	<li><a href='../date/2007/08.html' title='Август 2007'>Август 2007</a></li>
	<li><a href='../date/2007/07/index.html' title='Июль 2007'>Июль 2007</a></li>
	<li><a href='../date/2007/06.html' title='Июнь 2007'>Июнь 2007</a></li>
	<li><a href='../date/2007/05.html' title='Май 2007'>Май 2007</a></li>
				</ul>
			</li>

			
					</ul>
	</div>

</div> <!-- wrapper -->
<div id="footer">
	<a href="../../feed">Entries (RSS)</a> and <a href="../../comments/feed">Comments (RSS)</a>. Valid <a href="http://validator.w3.org/check/referer" title="This page validates as XHTML 1.0 Transitional"><abbr title="eXtensible HyperText Markup Language">XHTML</abbr></a> and <a href="http://jigsaw.w3.org/css-validator/check/referer"><abbr title="Cascading Style Sheets">CSS</abbr></a>.<br />
	Powered by <a href="http://wordpress.org/" title="Powered by WordPress.">WordPress</a> and <a href="http://srinig.com/wordpress/themes/fluid-blue/">Fluid Blue theme</a>.<br />
	<!-- 15 queries. 0.099 seconds. -->
	</div>
</div> <!-- page -->
</body>
</html>
